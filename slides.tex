\usepackage{minted}

% Hour-long talk

\title{Stop overusing regular expressions!}
\author{Franklin Chen \\ \url{http://franklinchen.com/}}
\date{\href{http://www.pghtechfest.com/}{Pittsburgh Tech Fest 2013} \\
June 1, 2013
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

%\section*{Outline}
%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents[pausesections]
%\end{frame}

\begin{frame}
  \frametitle{Famous quote}

  In 1997, \href{http://groups.google.com/forum/?hl=en&fromgroups\#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ}{Jamie Zawinski famously wrote}:

  \begin{quotation}
    Some people, when confronted with a problem, think, ``I know, I'll use regular expressions.''

    Now they have two problems.
  \end{quotation}
\end{frame}

\begin{frame}
  \frametitle{Purpose of this talk}

  Assumption: you already have experience using regexes

  Goals:
  \begin{itemize}
    \item Change how you think about and use regexes
    \item Introduce you to advantages of using parser combinators
    \item Show a smooth way to transition from regexes to parsers
    \item Discuss \emph{practical} tradeoffs
    \item Show only tested, running code: \url{https://github.com/franklinchen/talk-on-overusing-regular-expressions}
  \end{itemize}

  Non-goals:
  \begin{itemize}
    \item Will not discuss computer science theory
    \item Will not discuss parser generators such as \texttt{yacc} and \href{http://www.antlr.org/}{\texttt{ANTLR}}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example code in which languages?}

  Considerations:
  \begin{itemize}
    \item This is a \emph{polyglot} conference
    \item Time limitations
  \end{itemize}

  Decision: focus primarily on two representative languages.
  \begin{itemize}
    \item \href{http://www.ruby-lang.org/}{Ruby}: dynamic typing
      \begin{itemize}
        \item Perl, Python, JavaScript, Clojure, etc.
      \end{itemize}
    \item \href{http://www.scala-lang.org/}{Scala}: static typing: 
      \begin{itemize}
        \item Java, C++, C\#, F\#, ML, Haskell, etc.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{An infamous regex for email}

  The reason for my talk!

  \href{http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html}{A big Perl regex for email address based on RFC 822 grammar}:

  % Use text instead of perl because of syntax highlighting bug in Pygments
  \inputminted{text}{extra/rfc-822.pl}
\end{frame}

\begin{frame}
  \frametitle{Personal story: my email address fiasco}

  To track and prevent spam: \texttt{FranklinChen+spam@cmu.edu}

  \begin{itemize}
    \item Some sites \emph{wrongly} claimed invalid (because of \texttt{+})
    \item Other sites did allow registration
      \begin{itemize}
        \item I caught spam
        \item Unsubscribing failed!
          \begin{itemize}
            \item Some wrong claimed invalid (!?!)
            \item Some silently failed to unsubscribe
            \item Had to set up spam filter
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Problem: different regexes for email?}

  Examples: which one is better?

  \begin{minted}{ruby}
/\A[^@]+@[^@]+\z/
  \end{minted}

  vs.
  
  \begin{minted}{ruby}
/\A[a-zA-Z]+@([^@\.]+\.)+[^@\.]+\z/
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Readability: first example}

  Use \texttt{x} for readability!

  \begin{minted}{ruby}
/\A        # match string begin
   [^@]+     # local part: 1+ chars of not @
   @         # @
   [^@]+     # domain: 1+ chars of not @
   \z/x    # match string end
  \end{minted}
  % Note Pygments does not highlight internals of Ruby regexes!

  matches

  \begin{minted}{text}
FranklinChen+spam
@
cmu.edu
  \end{minted}

  Advice: please write regexes in this formatted style!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Readability: second example}

  \begin{minted}{ruby}
/\A        # match string begin
   [a-zA-Z]+ # local part: 1+ of Roman alphabetic
   @         # @
   (         # 1+ of this group
     [^@\.]+   # 1+ of not (@ or dot)
     \.        # dot
   )+
   [^@\.]+   # 1+ of not (@ or dot)
 \z/x      # match string end
  \end{minted}

  does \emph{not} match

  \begin{minted}{text}
FranklinChen+spam
@
cmu.edu
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Don't Do It Yourself: find libraries}

  Infamous regex revisited: was automatically generated into the Perl module \href{http://search.cpan.org/~pdwarren/Mail-RFC822-Address-0.3/Address.pm}{\texttt{Mail::RFC822::Address}} based on the RFC 822 spec.

  If you use Perl and need to validate email addresses:
  \begin{minted}{console}
# Install the library
$ cpanm Mail::RFC822::Address
  \end{minted}

  Other Perl regexes: \href{http://search.cpan.org/dist/Regexp-Common/}{\texttt{Regexp::Common}}
\end{frame}

% TODO no time
%\input{frames/use-perl-library.tex}

\begin{frame}[fragile]
  \frametitle{Regex match success vs. failure}

  Parentheses for captured grouping:
  \begin{minted}{perl}
if ($address =~ /\A        # match string begin
  ([a-zA-Z]+) # $1: local part: 1+ Roman alphabetic
  @           # @
  (           # $2: entire domain
    (?:         # 1+ of this non-capturing group
      [^@\.]+     # 1+ of not (@ or dot)
      \.          # dot
    )+
    ([^@\.]+) # $3: 1+ of not (@ or dot)
  )
   \z/x) {    # match string end
    print "local part: $1; domain: $2; top level: $3\n";
}
else {
    print "Regex match failed!\n";
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Regexes do not report errors usefully}

  Success:
  \begin{minted}{console}
$ perl/extract_parts.pl 'prez@whitehouse.gov'
local part: prez; domain: whitehouse.gov; top level: gov
  \end{minted}

  But failure:
  \begin{minted}{console}
$ perl/extract_parts.pl 'FranklinChen+spam@cmu.edu'
Regex match failed!
  \end{minted}
  
% Stuck to Perl for showing extraction instead.
%  \inputminted{scala}{extra/regex-match.scala}

  We have a dilemma:
  \begin{itemize}
    \item Bug in the regex?
    \item The data really doesn't match?
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Better error reporting: how?}

  Would prefer something at least minimally like:

  \begin{minted}{console}
[1.13] failure: `@' expected but `+' found

FranklinChen+spam@cmu.edu
            ^
  \end{minted}

  Features of \emph{parser} libraries:
  \begin{itemize}
    \item Extraction of line, column information of error
    \item Automatically generated error explanation
    \item Hooks for customizing error explanation
    \item Hooks for error recovery
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Moving from regexes to grammar parsers}

  \begin{itemize}
    \item Only discuss parser combinators, not generators
    \item Use the second email regex as a starting point
    \item Use modularization
  \end{itemize}
\end{frame}

% No time
% Confusing because different regex
%\input{frames/perl-modularized-regex.tex}

% Parser tests

%\input{frames/parser-tests-scala.tex}
%\input{frames/parser-tests-ruby.tex}

% Finally switch to Ruby

\begin{frame}[fragile]
  \frametitle{Modularized regex: Ruby}

  Ruby allows interpolation of regexes into other regexes:

  \begin{minted}{ruby}
LOCAL_PART = /[a-zA-Z]+/x
AT = /@/x
DOMAIN_CHAR = /[^@\.]/x
SUB_DOMAIN = /#{DOMAIN_CHAR}+/x
DOT = /\./x
DOMAIN = /(#{SUB_DOMAIN}#{DOT})+ #{SUB_DOMAIN}/x
EMAIL = /
    \A
    #{LOCAL_PART}
    #{AT}
    #{DOMAIN}
    \z
  /x
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modularized regex: Scala}

  \begin{minted}{scala}
val user = """[a-zA-Z]+"""
val at = """@"""
val domainSegment = """[^@\.]+"""
val dot = """\."""
val email = raw"""(?x)
  \A
  $user
  $at
  (
    $domainSegment $dot
  )+
  $domainSegment
  \z"""

val emailRegex = email.r
  \end{minted}

  Scala notes:
  \begin{itemize}
    \item Triple quotes are for raw strings (no backslash interpretation)
    \item \texttt{raw} allows variable interpolation in raw strings
    \item \texttt{.r} is a method converting \texttt{String} to \href{http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex}{\texttt{Regex}}
  \end{itemize}
\end{frame}

% First parser: email
% Ruby first, then Scala

\begin{frame}[fragile]
  \frametitle{Email parser: Ruby}

  Ruby does not have a standard parser combinator library. One that is popular is \href{http://kschiess.github.io/parslet/}{Parslet}.

  \inputminted{ruby}{ruby/lib/email_validator/parser.rb}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Email parser: Scala}

  Scala comes with \href{http://www.scala-lang.org/api/current/index.html\#scala.util.parsing.combinator.Parsers}{standard parser combinator library}.

  \inputminted{scala}{extra/EmailParsers.scala}

  Inheriting from \texttt{RegexParsers} allows the implicit conversions from regexes into parsers.
\end{frame}

% Error reporting

\begin{frame}[fragile]
  \frametitle{Error reporting: Ruby}

  We have achieved the goal of decent error reporting:

  \begin{minted}{ruby}
begin
  parser.email.parse(address)
  puts "Successfully parsed #{address}"
rescue Parslet::ParseFailed => error
  puts "Parse failed, and here's why:"
  puts error.cause.ascii_tree
end
  \end{minted}

  \begin{minted}{console}
$ bundle exec bin/validate_email 'FranklinChen+spam@cmu.edu'
Parse failed, and here's why:
Failed to match sequence (LOCAL_PART AT DOMAIN) at line 1 char 13.
`- Expected "@", but got "+" at line 1 char 13.
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Error reporting: Scala}

  We have achieved the goal of decent error reporting:

  \begin{minted}{scala}
parseAll(email, address) match {
  case Success(_, _) =>
    println(s"Successfully parsed $address")
  case failure: NoSuccess =>
    println("Parse failed, and here's why:")
    println(failure)
}
  \end{minted}

  \begin{minted}{console}
Parse failed, and here's why:
[1.13] failure: `@' expected but `+' found

FranklinChen+spam@cmu.edu
            ^
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Infamous email regex: revisited}

  \begin{itemize}
    \item \texttt{Mail::RFC822::Address} Perl regex: actually manually back-converted from a parser!
    \item Original module used Perl parser library \href{http://search.cpan.org/~jtbraun/Parse-RecDescent-1.967009/lib/Parse/RecDescent.pm}{\texttt{Parse::RecDescent}}
  \end{itemize}

  \begin{itemize}
    \item Regex author turned the grammar rules into a modularized regex
    \item Reason: speed
  \end{itemize}

  Perl modularized regex \href{http://cpansearch.perl.org/src/PDWARREN/Mail-RFC822-Address-0.3/Address.pm}{source code excerpt}:
  \begin{minted}{perl}
my $localpart = "$word(?:\\.$lwsp*$word)*";
my $sub_domain = "(?:$atom|$domain_literal)";
my $domain = "$sub_domain(?:\\.$lwsp*$sub_domain)*";
my $addr_spec = "$localpart\@$lwsp*$domain";
  \end{minted}
\end{frame}

% TODO no time
%\input{frames/generators.tex}

\begin{frame}
  \frametitle{Why validate email address anyway?}

  Look at the bigger picture.

  This guy advocates \href{http://davidcel.is/blog/2012/09/06/stop-validating-email-addresses-with-regex/}{simply sending a user an activation email}.

  Engineering tradeoff: the email sending and receiving programs need to handle the email address anyway.
\end{frame}

\begin{frame}
  \frametitle{Email example wrapup}

  \begin{itemize}
    \item It is possible to write a regex
    \item But you may want to use someone else's regex
    \item If you write a regex, modularize it
    \item For error reporting, use a parser: convert from modularized regex
    \item Do you even need to solve the problem?
  \end{itemize}
\end{frame}

% JSON examples

\begin{frame}[fragile]
  \frametitle{Example: toy JSON parsing}

  \inputminted{json}{javascript/example.json}

  \begin{itemize}
    \item Would you use a regex to parse?
    \item Could you use a regex to parse?
  \end{itemize}
\end{frame}

% TODO no time
%\input{frames/recursive-regexes.tex}

\begin{frame}[fragile]
  \frametitle{Toy JSON parser: Scala}

  (To save time: no more Ruby code in this presentation.)

  \begin{minted}{scala}
object ToyJSONParsers extends JavaTokenParsers {
  def value: Parser[Any] = obj |
    arr |
    stringLiteral |
    floatingPointNumber |
    "null" |
    "true" | "false"
  def obj = "{" ~ repsep(member, ",") ~ "}"
  def arr = "[" ~ repsep(value, ",") ~ "]"
  def member = stringLiteral ~ ":" ~ value
}
  \end{minted}

  Inheriting from \texttt{JavaTokenParsers} allows the reuse of \texttt{stringLiteral} and \texttt{floatingPointNumber} parsers.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fancier toy JSON parser: use the data}

  Want to actually shape and use the data parsed.

  \inputminted{json}{javascript/example.json}
  
  Example: traverse the JSON to \texttt{address} and then to the second neighbor, \texttt{Y}.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Domain modeling: Scala}

  \begin{minted}{scala}
sealed trait ToyJSON

case class JObject(map: Map[String, ToyJSON]) extends
  ToyJSON
case class JArray(list: List[ToyJSON]) extends ToyJSON
case class JString(string: String) extends ToyJSON
case class JFloat(float: Float) extends ToyJSON
case object JNull extends ToyJSON
case class JBoolean(boolean: Boolean) extends ToyJSON
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fancier toy JSON parser: Scala}

  \begin{minted}{scala}
def value: Parser[ToyJSON] = obj | arr |
  stringLiteralStripped ^^ { JString(_) } |
  floatingPointNumber ^^ { s => JFloat(s.toFloat) } |
  "null" ^^^ JNull | "true" ^^^ JBoolean(true) |
  "false" ^^^ JBoolean(false)
def stringLiteralStripped: Parser[String] =
  stringLiteral ^^ { s => s.substring(1, s.length-1) }
def obj: Parser[JObject] = "{" ~> (repsep(member, ",") ^^
     { aList => JObject(aList.toMap) }) <~ "}"
def arr: Parser[JArray] = "[" ~> (repsep(value, ",") ^^
     { aList => JArray(aList) }) <~ "]"
def member: Parser[(String, ToyJSON)] =
  ((stringLiteralStripped <~ ":") ~ value) ^^
   { case s ~ v => s -> v }
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using the parsed JSON}

  A test using \href{http://etorreborre.github.io/specs2/}{Specs2} Scala testing framework:

  \begin{minted}{scala}
parsers.value must succeedOn("""{
  "distance" : 5.6,
  "address" : {
    "street" : "0 Nowhere Road",
    "neighbors" : ["X", "Y"],
    "garage" : null
  }
}""").withResult({ result: ToyJSON =>
  result.asInstanceOf[JObject].
    map("address").asInstanceOf[JObject].
    map("neighbors").asInstanceOf[JArray].
    list(1).asInstanceOf[JString].
    string
} ^^ be_==("Y"))
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{JSON: reminder not to reinvent}

  \begin{itemize}
    \item<1-> Use a standard JSON parsing library!
      \begin{itemize}
        \item<2-> \href{http://www.scala-lang.org/api/current/index.html\#scala.util.parsing.json.JSON$}{Scala has one.}
        \item<3-> All languages have a standard JSON parsing library.
        \item<4-> Shop around: alternate libraries have different tradeoffs.
      \end{itemize}
    \item<5-> Other standard formats: HTML, XML, CSV, etc.
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{JSON wrapup}

  \begin{itemize}
    \item<1-> Just parsing is simple
    \item<2-> Domain modeling is trickier
    \item<3-> \emph{Use an existing JSON parsing library already!} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Final example of real regex code}

  Recently in \href{http://octopress.org/}{Octopress} \href{https://github.com/imathis/octopress/blob/3bb4a14212b226d1da3acd546584d7117557a1ae/lib/octopress/liquid\_helpers/conditional.rb}{Ruby code}:

  \inputminted{ruby}{extra/conditional.rb}

  Depending on the nature of corner cases and nesting, real parser might be preferable.
\end{frame}

% TODO
% Pygments example
% Was true when highlighting as Perl
% Distracting
%  By the way: note the bug in \href{http://pygments.org/}{Pygments} syntax highlighter I use for my slides!

\begin{frame}
  \frametitle{Conclusion}

  \begin{itemize}
    \item Regular expressions
      \begin{itemize}
        \item No error reporting
        \item Flat data
      \end{itemize}
    \item More general grammars
      \begin{itemize}
        \item Composable structure (using combinator parsers)
        \item Hierarchical, nested data
      \end{itemize}
    \item Avoid reinventing
  \end{itemize}

  All materials for this talk available at \url{https://github.com/franklinchen/talk-on-overusing-regular-expressions}. The hyperlinks on the slide PDFs are clickable.
\end{frame}

\end{document}
